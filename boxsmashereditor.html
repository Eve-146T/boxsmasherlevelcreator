<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Smasher - Level Editor v3.2</title>
    <style>
        :root {
            --bg-dark: #2c3e50; --bg-light: #34495e; --accent: #3498db;
            --text-light: #ecf0f1; --border-color: #7f8c8d; --danger: #e74c3c;
            --success: #2ecc71; --warning: #f1c40f; --info: #9b59b6;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex; background-color: var(--bg-dark); color: var(--text-light);
            margin: 0; height: 100vh; overflow: hidden;
        }
        #editor-container {
            flex-grow: 1; display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 20px; overflow: auto; background: #233546;
        }
        canvas {
            background-color: #2b402b; cursor: crosshair;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); border: 2px solid var(--border-color);
        }
        #sidebar {
            width: 320px; min-width: 320px; background-color: var(--bg-light);
            padding: 15px; box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; overflow-y: auto;
        }
        .panel {
            background-color: var(--bg-dark); border-radius: 5px;
            padding: 15px; margin-bottom: 20px;
        }
        h3, h4 {
            margin-top: 0; border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .tool-buttons {
            display: flex; flex-wrap: wrap; gap: 10px;
        }
        button, select {
            background-color: var(--accent); color: var(--text-light); border: none;
            padding: 10px; border-radius: 4px; cursor: pointer;
            transition: background-color 0.2s; font-size: 14px;
            box-sizing: border-box; width: 100%;
        }
        button:hover { background-color: #2980b9; }
        button.tool-btn { flex: 1 1 calc(50% - 5px); min-width: 120px; }
        button.active {
            background-color: var(--success); box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        button.info { background-color: var(--info); }
        button.info:hover { background-color: #8e44ad; }
        button.danger { background-color: var(--danger); }
        button.danger:hover { background-color: #c0392b; }
        button.export {
            background-color: var(--warning); padding: 15px;
            font-size: 16px; font-weight: bold;
        }
        button.export:hover { background-color: #e67e22; }
        .property-grid {
            display: grid; grid-template-columns: auto 1fr;
            gap: 10px; align-items: center;
        }
        label { font-weight: bold; }
        input[type="text"], input[type="number"], input[type="color"], select {
            width: 100%; background-color: var(--bg-light); border: 1px solid var(--border-color);
            color: var(--text-light); padding: 8px; border-radius: 3px;
        }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--bg-light); margin: auto; padding: 20px;
            border: 1px solid #888; width: 90%; max-width: 800px;
            border-radius: 8px; display: flex; flex-direction: column;
            max-height: 90vh;
        }
        .modal-body { overflow-y: auto; }
        .modal-content textarea {
            width: 100%; height: 400px; background-color: #1e2b38; color: #d0d0d0;
            font-family: 'Courier New', Courier, monospace; border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; flex-shrink: 0;
        }
        .custom-element-form {
            background: var(--bg-dark); padding: 15px; border-radius: 5px; margin-bottom: 20px;
        }
        .custom-element-list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; background: var(--bg-dark); border-radius: 4px; margin-bottom: 8px;
        }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="panel">
            <h3>Editing Tools</h3>
            <div class="tool-buttons">
                <button id="tool-select" class="tool-btn active">Select</button>
                <button id="tool-throw-area" class="tool-btn">Throw Area</button>
            </div>
        </div>
        
        <div class="panel">
            <h3>Standard Tools</h3>
            <div id="standard-tools" class="tool-buttons"></div>
        </div>

        <div class="panel">
            <h3>Custom Tools</h3>
            <div id="custom-tools" class="tool-buttons"></div>
            <br>
            <button id="manage-custom-btn" class="info">Manage Custom Elements</button>
        </div>

        <div class="panel">
            <h3>Level Settings</h3>
            <div class="property-grid">
                <label for="level-author">Author:</label> <input type="text" id="level-author" value="EditorUser">
                <label for="level-balls">Balls:</label> <input type="number" id="level-balls" value="3" min="1">
            </div>
             <br>
            <button id="clear-btn" class="danger">Clear Level</button>
        </div>

        <div id="inspector-panel" class="panel" style="display: none;">
            <h3 id="inspector-title">Properties</h3>
            <div id="inspector-properties" class="property-grid"></div>
            <br>
            <button id="delete-btn" class="danger">Delete Selected</button>
        </div>

        <div style="margin-top: auto; flex-shrink: 0;">
             <button id="export-btn" class="export">Export to .lua file</button>
        </div>
    </div>

    <div id="editor-container">
        <canvas id="editor-canvas" width="1280" height="720"></canvas>
    </div>

    <div id="export-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Generated Lua Code</h2>
                <button class="close-modal-btn">Close</button>
            </div>
            <textarea id="lua-output" readonly></textarea>
            <button id="copy-lua-btn">Copy to Clipboard</button>
        </div>
    </div>
    
    <div id="custom-element-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Manage Custom Elements</h2>
                <button class="close-modal-btn">Close</button>
            </div>
            <div class="modal-body">
                <div class="custom-element-form">
                    <h4>Create New Element</h4>
                    <div class="property-grid">
                        <label for="custom-name">Name:</label> <input type="text" id="custom-name" placeholder="e.g., Icy Platform">
                        <label for="custom-base-type">Type:</label>
                        <select id="custom-base-type">
                            <option value="terrain">Wall / Platform</option>
                            <option value="boxcluster">Box Cluster</option>
                        </select>
                    </div>
                    <div id="custom-properties-container"></div>
                    <br>
                    <button id="add-custom-element-btn" class="success">Add New Tool</button>
                </div>
                <h4>Existing Custom Tools</h4>
                <div id="custom-element-list"></div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('editor-canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 40;
        const RES_X = 1280;
        const RES_Y = 720;

        const TERRAIN_PRESETS = {
            normal: { name: 'Non-Bouncy Wall', type: 'terrain', friction: 0.5, restitution: 0.33, colour: [125, 227, 102] },
            bouncy: { name: 'Bouncy Wall', type: 'terrain', friction: 0.5, restitution: 0.75, colour: [227, 125, 102] },
            very_bouncy: { name: 'Very Bouncy Wall', type: 'terrain', friction: 0.75, restitution: 2.0, colour: [209, 156, 56] },
        };
        const BOX_PRESETS = {
            small: { name: 'Small Cubes (20x20)', type: 'boxcluster', w: 20, h: 20},
            medium: { name: 'Medium Cubes (40x40)', type: 'boxcluster', w: 40, h: 40},
            large: { name: 'Big Cubes (60x60)', type: 'boxcluster', w: 60, h: 60},
        };

        let level = { author: 'EditorUser', totalBalls: 3, throwBoundary: { x: 40, y: 120, w: 220, h: 480 }, boxclusters: [], terrain: [] };
        let customElements = [];
        
        let activeTool = 'select';
        let activePreset = null;
        let selectedObject = null;
        let isDrawing = false, isDragging = false, isResizing = false;
        let resizeHandle = null;
        let startPos = {}, currentMousePos = {}, dragOffset = {};

        // --- DATA MANAGEMENT ---
        const saveState = () => localStorage.setItem('boxSmasherLevelData', JSON.stringify(level));
        const loadState = () => {
            const data = localStorage.getItem('boxSmasherLevelData');
            if(data) level = JSON.parse(data);
            document.getElementById('level-author').value = level.author;
            document.getElementById('level-balls').value = level.totalBalls;
        };
        const saveCustomElements = () => localStorage.setItem('boxSmasherCustomElements', JSON.stringify(customElements));
        const loadCustomElements = () => {
            const data = localStorage.getItem('boxSmasherCustomElements');
            if(data) customElements = JSON.parse(data);
        };

        // --- DRAWING ---
        const drawGrid = () => {
            ctx.strokeStyle = 'rgba(127, 140, 141, 0.2)'; ctx.lineWidth = 1;
            for (let x = 0; x < RES_X; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, RES_Y); ctx.stroke(); }
            for (let y = 0; y < RES_Y; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(RES_X, y); ctx.stroke(); }
        };

        const drawObject = (obj, type) => {
            const colorToRGB = (c) => `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
            ctx.lineWidth = 2; ctx.strokeStyle = '#000';

            if (type === 'terrain') {
                ctx.fillStyle = colorToRGB(obj.colour || TERRAIN_PRESETS.normal.colour);
                ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            } else if (type === 'boxcluster') {
                ctx.fillStyle = 'rgba(224, 85, 85, 0.6)'; ctx.strokeStyle = 'rgba(150, 40, 40, 0.8)'; ctx.lineWidth = 1;
                for(let i=0; i<obj.aX; i++) for(let j=0; j<obj.aY; j++) {
                    const x = obj.x + i * obj.w; const y = obj.y + j * obj.h;
                    ctx.fillRect(x, y, obj.w, obj.h); ctx.strokeRect(x, y, obj.w, obj.h);
                }
            } else if (type === 'throwBoundary') {
                ctx.strokeStyle = `rgba(${TERRAIN_PRESETS.very_bouncy.colour.join(',')}, 0.9)`; ctx.lineWidth = 5;
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            }
        };
        
        const drawSelection = (obj) => {
            if (!obj) return;
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.setLineDash([6, 6]);
            const { width, height } = getObjectBounds(obj);
            ctx.strokeRect(obj.x, obj.y, width, height);
            ctx.setLineDash([]);
            
            const handles = getResizeHandles(obj);
            ctx.fillStyle = '#3498db';
            for (const handle in handles) {
                ctx.fillRect(handles[handle].x - 5, handles[handle].y - 5, 10, 10);
            }
        };
        
        const drawPreview = () => {
            if (!isDrawing || activeTool === 'select' || (activeTool !== 'throw-area' && !activePreset)) return;

            const x = Math.min(startPos.x, currentMousePos.x);
            const y = Math.min(startPos.y, currentMousePos.y);
            const w = Math.abs(startPos.x - currentMousePos.x);
            const h = Math.abs(startPos.y - currentMousePos.y);
            if (w < 1 || h < 1) return;

            if (activeTool === 'throw-area') {
                ctx.strokeStyle = `rgba(${TERRAIN_PRESETS.very_bouncy.colour.join(',')}, 0.8)`; ctx.lineWidth = 5;
                ctx.strokeRect(x, y, w, h);
                return;
            }

            const previewObj = activePreset;
            if (previewObj.type === 'terrain') {
                ctx.fillStyle = `rgba(${(previewObj.colour || TERRAIN_PRESETS.normal.colour).join(',')}, 0.6)`;
                ctx.fillRect(x, y, w, h);
            } else if (previewObj.type === 'boxcluster') {
                const boxW = previewObj.w; const boxH = previewObj.h;
                const aX = Math.max(1, Math.round(w / boxW));
                const aY = Math.max(1, Math.round(h / boxH));
                ctx.fillStyle = 'rgba(224, 85, 85, 0.5)'; ctx.strokeStyle = 'rgba(150, 40, 40, 0.7)'; ctx.lineWidth = 1;
                for (let i=0; i<aX; i++) for (let j=0; j<aY; j++) {
                    ctx.fillRect(x + i*boxW, y + j*boxH, boxW, boxH);
                    ctx.strokeRect(x + i*boxW, y + j*boxH, boxW, boxH);
                }
            }
        };
        
        const mainDrawLoop = () => {
            ctx.clearRect(0, 0, RES_X, RES_Y);
            drawGrid();
            level.terrain.forEach(o => drawObject(o, 'terrain'));
            level.boxclusters.forEach(o => drawObject(o, 'boxcluster'));
            drawObject(level.throwBoundary, 'throwBoundary');
            drawSelection(selectedObject);
            drawPreview();
            requestAnimationFrame(mainDrawLoop);
        };

        // --- OBJECT & UI LOGIC ---
        const getRawMousePos = e => { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; };
        const snapToGrid = pos => ({ x: Math.round(pos.x / GRID_SIZE) * GRID_SIZE, y: Math.round(pos.y / GRID_SIZE) * GRID_SIZE });
        const getObjectBounds = obj => ({ width: obj.type === 'boxcluster' ? obj.w * obj.aX : obj.w, height: obj.type === 'boxcluster' ? obj.h * obj.aY : obj.h });

        const getResizeHandles = (obj) => {
             if (!obj) return {};
             const { width, height } = getObjectBounds(obj);
             return {
                'top-left': {x: obj.x, y: obj.y, cursor: 'nwse-resize'}, 'top-right': {x: obj.x + width, y: obj.y, cursor: 'nesw-resize'},
                'bottom-left': {x: obj.x, y: obj.y + height, cursor: 'nesw-resize'}, 'bottom-right': {x: obj.x + width, y: obj.y + height, cursor: 'nwse-resize'},
             };
        };

        const checkResizeHandleHit = (pos, obj) => {
            const handles = getResizeHandles(obj);
            for (const name in handles) if (pos.x >= handles[name].x - 8 && pos.x <= handles[name].x + 8 && pos.y >= handles[name].y - 8 && pos.y <= handles[name].y + 8) return name;
            return null;
        };

        const checkHit = (pos, obj) => {
            const { width, height } = getObjectBounds(obj);
            return pos.x >= obj.x && pos.x <= obj.x + width && pos.y >= obj.y && pos.y <= obj.y + height;
        };

        const getObjectAt = (pos) => {
            if (checkHit(pos, level.throwBoundary)) return { ...level.throwBoundary, type: 'throwBoundary' };
            for (let i = level.terrain.length - 1; i >= 0; i--) if (checkHit(pos, level.terrain[i])) return { ...level.terrain[i], type: 'terrain', index: i };
            for (let i = level.boxclusters.length - 1; i >= 0; i--) if (checkHit(pos, level.boxclusters[i])) return { ...level.boxclusters[i], type: 'boxcluster', index: i };
            return null;
        };
        
        const setSelectedObject = obj => { selectedObject = obj; updateInspector(); };
        const getLiveObjectReference = obj => {
             if (!obj) return null;
             if (obj.type === 'throwBoundary') return level.throwBoundary;
             if (obj.type === 'terrain') return level.terrain[obj.index];
             if (obj.type === 'boxcluster') return level.boxclusters[obj.index];
             return null;
        };
        const deleteSelected = () => {
            if (!selectedObject || selectedObject.type === 'throwBoundary') return;
            if (selectedObject.type === 'terrain') level.terrain.splice(selectedObject.index, 1);
            else if (selectedObject.type === 'boxcluster') level.boxclusters.splice(selectedObject.index, 1);
            setSelectedObject(null);
            saveState();
        };

        // --- TOOL BUTTON & PRESET LOGIC ---
        const populateTools = () => {
            const stdTools = document.getElementById('standard-tools');
            const cstTools = document.getElementById('custom-tools');
            stdTools.innerHTML = ''; cstTools.innerHTML = '';

            const createToolBtn = (preset, container) => {
                const btn = document.createElement('button');
                btn.className = 'tool-btn';
                btn.textContent = preset.name;
                btn.dataset.toolId = preset.name; // Unique ID for finding the button
                btn.addEventListener('click', () => {
                    document.querySelector('.tool-btn.active')?.classList.remove('active');
                    btn.classList.add('active');
                    activeTool = preset.type;
                    activePreset = preset;
                    setSelectedObject(null);
                });
                container.appendChild(btn);
            };

            Object.values(TERRAIN_PRESETS).forEach(p => createToolBtn(p, stdTools));
            Object.values(BOX_PRESETS).forEach(p => createToolBtn(p, stdTools));
            customElements.forEach(p => createToolBtn(p, cstTools));
        };
        
        // --- EVENT HANDLERS ---
        canvas.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            startPos = snapToGrid(getRawMousePos(e));
            isDrawing = true;

            if (activeTool === 'select') {
                const rawPos = getRawMousePos(e);
                const handle = selectedObject ? checkResizeHandleHit(rawPos, selectedObject) : null;
                
                if (handle) { isResizing = true; resizeHandle = handle; } 
                else {
                    const obj = getObjectAt(rawPos);
                    setSelectedObject(obj);
                    if (obj) { isDragging = true; dragOffset.x = rawPos.x - obj.x; dragOffset.y = rawPos.y - obj.y; }
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            const rawPos = getRawMousePos(e);
            currentMousePos = snapToGrid(rawPos);

            let cursor = 'crosshair';
            if (activeTool === 'select') {
                cursor = 'default';
                const handle = selectedObject ? checkResizeHandleHit(rawPos, selectedObject) : null;
                if (handle) { cursor = getResizeHandles(selectedObject)[handle].cursor; } 
                else if (getObjectAt(rawPos)) { cursor = 'move'; }
            }
            canvas.style.cursor = cursor;

            if (isResizing && selectedObject) {
                 const objRef = getLiveObjectReference(selectedObject);
                 const { width, height } = getObjectBounds(objRef);
                 const oldRight = objRef.x + width, oldBottom = objRef.y + height;
                 const newPos = snapToGrid(rawPos);

                 if (resizeHandle.includes('left')) { const newWidth = oldRight - newPos.x; if(objRef.type === 'boxcluster') objRef.w = newWidth / objRef.aX; else objRef.w = newWidth; objRef.x = newPos.x; }
                 if (resizeHandle.includes('right')) { const newWidth = newPos.x - objRef.x; if(objRef.type === 'boxcluster') objRef.w = newWidth / objRef.aX; else objRef.w = newWidth; }
                 if (resizeHandle.includes('top')) { const newHeight = oldBottom - newPos.y; if(objRef.type === 'boxcluster') objRef.h = newHeight / objRef.aY; else objRef.h = newHeight; objRef.y = newPos.y; }
                 if (resizeHandle.includes('bottom')) { const newHeight = newPos.y - objRef.y; if(objRef.type === 'boxcluster') objRef.h = newHeight / objRef.aY; else objRef.h = newHeight; }

                 setSelectedObject({...objRef, type: selectedObject.type, index: selectedObject.index});
                 updateInspector(); saveState();
                 return;
            }

            if (isDragging && selectedObject) {
                const objRef = getLiveObjectReference(selectedObject);
                if (objRef) {
                    objRef.x = snapToGrid({x: rawPos.x - dragOffset.x, y: 0}).x;
                    objRef.y = snapToGrid({x: 0, y: rawPos.y - dragOffset.y}).y;
                    setSelectedObject({...objRef, type: selectedObject.type, index: selectedObject.index});
                    updateInspector(); saveState();
                }
                return;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false; isDragging = false; isResizing = false;
            
            const endPos = snapToGrid(getRawMousePos(e));
            const x = Math.min(startPos.x, endPos.x), y = Math.min(startPos.y, endPos.y);
            const w = Math.abs(startPos.x - endPos.x), h = Math.abs(startPos.y - endPos.y);

            if (w < GRID_SIZE / 2 && h < GRID_SIZE / 2) return;

            if (activeTool === 'throw-area') {
                level.throwBoundary = { x, y, w, h };
            } else if (activePreset) {
                if (activePreset.type === 'terrain') {
                    const newObj = { x, y, w, h, ...activePreset };
                    delete newObj.name; level.terrain.push(newObj);
                } else if (activePreset.type === 'boxcluster') {
                    const boxW = activePreset.w; const boxH = activePreset.h;
                    const aX = Math.max(1, Math.round(w / boxW)); const aY = Math.max(1, Math.round(h / boxH));
                    const newObj = { ...activePreset, x, y, aX, aY };
                    delete newObj.name; level.boxclusters.push(newObj);
                }
            }
            if(activeTool !== 'select') saveState();
        });
        
        document.querySelectorAll('#sidebar .tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelector('.tool-btn.active')?.classList.remove('active');
                e.target.classList.add('active');
                activeTool = e.target.id.replace('tool-', '');
                activePreset = null; // Clear preset for select/throw-area
                setSelectedObject(null);
            });
        });
        
        // --- CUSTOM ELEMENT MODAL ---
        const customElementModal = document.getElementById('custom-element-modal');
        const customPropsContainer = document.getElementById('custom-properties-container');
        const updateCustomForm = () => {
            const type = document.getElementById('custom-base-type').value;
            customPropsContainer.innerHTML = `<div class="property-grid">${type === 'terrain' ? `
                <label for="custom-friction">Friction:</label> <input type="number" id="custom-friction" value="0.5" step="0.1">
                <label for="custom-restitution">Restitution:</label> <input type="number" id="custom-restitution" value="0.33" step="0.1">
                <label for="custom-colour">Color:</label> <input type="color" id="custom-colour" value="#7de366">` : `
                <label for="custom-w">Box Width:</label> <input type="number" id="custom-w" value="40" min="1">
                <label for="custom-h">Box Height:</label> <input type="number" id="custom-h" value="40" min="1">`}
            </div>`;
        };
        const populateCustomElementList = () => {
            const listDiv = document.getElementById('custom-element-list');
            listDiv.innerHTML = '';
            customElements.forEach((el, index) => {
                const item = document.createElement('div'); item.className = 'custom-element-list-item';
                item.innerHTML = `<span>${el.name} (${el.type})</span>`;
                const delBtn = document.createElement('button'); delBtn.textContent = 'Delete'; delBtn.className = 'danger'; delBtn.style.width = 'auto';
                delBtn.onclick = () => { customElements.splice(index, 1); saveCustomElements(); populateTools(); populateCustomElementList(); };
                item.appendChild(delBtn); listDiv.appendChild(item);
            });
        };
        document.getElementById('manage-custom-btn').addEventListener('click', () => { customElementModal.style.display = 'flex'; updateCustomForm(); populateCustomElementList(); });
        document.getElementById('custom-base-type').addEventListener('change', updateCustomForm);
        document.getElementById('add-custom-element-btn').addEventListener('click', () => {
            const name = document.getElementById('custom-name').value;
            if (!name) { alert('Please enter a name.'); return; }
            const type = document.getElementById('custom-base-type').value;
            const newElement = { name, type };
            if (type === 'terrain') {
                newElement.friction = parseFloat(document.getElementById('custom-friction').value); newElement.restitution = parseFloat(document.getElementById('custom-restitution').value);
                const hex = document.getElementById('custom-colour').value; newElement.colour = [parseInt(hex.substr(1,2),16), parseInt(hex.substr(3,2),16), parseInt(hex.substr(5,2),16)];
            } else { newElement.w = parseInt(document.getElementById('custom-w').value); newElement.h = parseInt(document.getElementById('custom-h').value); }
            customElements.push(newElement); saveCustomElements(); populateTools(); populateCustomElementList(); document.getElementById('custom-name').value = '';
        });

        // --- OTHER HANDLERS ---
        document.getElementById('level-author').addEventListener('input', e => { level.author = e.target.value; saveState(); });
        document.getElementById('level-balls').addEventListener('input', e => { level.totalBalls = parseInt(e.target.value); saveState(); });
        document.getElementById('delete-btn').addEventListener('click', deleteSelected);
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm("Are you sure? This will delete all objects.")) { level.terrain = []; level.boxclusters = []; setSelectedObject(null); saveState(); }
        });
        document.addEventListener('keydown', e => { if ((e.key==='Delete' || e.key==='Backspace') && selectedObject && document.activeElement.tagName!=='INPUT') deleteSelected(); });
        
        function updateInspector() { /* Omitted for brevity */ }
        
        // --- EXPORT ---
        function formatTable(obj, indent) {
            const t = indent || '\t'; const parts = [];
            const keyOrder = ['x','y','w','h','aX','aY','colour','restitution','friction'];
            const objCopy = {...obj};
            delete objCopy.name; delete objCopy.type; delete objCopy.index;

            const sortedKeys = Object.keys(objCopy).sort((a,b) => (keyOrder.indexOf(a) || 99) - (keyOrder.indexOf(b) || 99));
            for(const key of sortedKeys) {
                const value = objCopy[key];
                if (value === undefined || value === null) continue; // FIX: Skip undefined/null properties
                let valueStr = '';
                if(typeof value === 'string') valueStr = `'${value}'`;
                else if(Array.isArray(value)) valueStr = `{ ${value.join(', ')} }`;
                else valueStr = value;
                parts.push(`${t}\t${key} = ${valueStr}`);
            }
            return `{\n${parts.join(',\n')}\n${t}}`;
        }
        function generateLua() {
            let str = `\nreturn {\n`; // FIX: Add leading newline
            str += `\tauthor = '${level.author}',\n`; str += `\ttotalBalls = ${level.totalBalls},\n`;
            str += `\tthrowBoundary = ${formatTable(level.throwBoundary)},\n`;
            str += `\tboxclusters = {\n`;
            level.boxclusters.forEach(b => { str += `\t\t${formatTable(b, '\t\t')},\n`; });
            str += `\t},\n`; str += `\tterrain = {\n`;
            level.terrain.forEach(t => { str += `\t\t${formatTable(t, '\t\t')},\n`; });
            str += `\t}\n`; str += `}\n`; return str;
        }

        const exportModal = document.getElementById('export-modal');
        document.getElementById('export-btn').addEventListener('click', () => { document.getElementById('lua-output').value = generateLua(); exportModal.style.display = 'flex'; });
        document.getElementById('copy-lua-btn').addEventListener('click', () => { document.getElementById('lua-output').select(); document.execCommand('copy'); });
        document.querySelectorAll('.close-modal-btn').forEach(btn => btn.addEventListener('click', (e) => {
            e.target.closest('.modal').style.display = 'none';
        }));
        
        // --- INIT ---
        loadState();
        loadCustomElements();
        populateTools();
        mainDrawLoop();
    });
    </script>
</body>
</html>